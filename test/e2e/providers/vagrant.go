package providers

import (
	"fmt"
	"io/ioutil"
	"os"
	"path"
	"runtime"

	"github.com/kevinburke/ssh_config"
	"golang.org/x/crypto/ssh"
)

func vagrantPath() (string, error) {
	// TODO: find a better way to get this path?
	_, fileName, _, ok := runtime.Caller(1)
	if !ok {
		return "", fmt.Errorf("cannot locate caller information")
	}
	return path.Join(path.Dir(path.Dir(fileName)), "infra", "vagrant"), nil
}

func importConfig() (*ssh_config.Config, error) {
	vagrantPath, err := vagrantPath()
	if err != nil {
		return nil, fmt.Errorf("cannot compute path to infra/vagrant")
	}
	configPath := path.Join(vagrantPath, "ssh-config")
	f, err := os.Open(configPath)
	if err != nil {
		return nil, fmt.Errorf("cannot open ssh-config file: %v", err)
	}
	config, err := ssh_config.Decode(f)
	if err != nil {
		return nil, fmt.Errorf("cannot decode ssh-config file: %v", err)
	}
	return config, nil
}

func convertConfig(inConfig *ssh_config.Config, name string) (string, *ssh.ClientConfig, error) {
	if inConfig == nil {
		return "", nil, fmt.Errorf("input config is nil")
	}

	hostName, err := inConfig.Get(name, "HostName")
	if err != nil {
		return "", nil, fmt.Errorf("cannot find HostName for '%s' in config: %v", name, err)
	}
	port, err := inConfig.Get(name, "Port")
	if err != nil {
		return "", nil, fmt.Errorf("cannot find Port for '%s' in config: %v", name, err)
	}
	host := fmt.Sprintf("%s:%s", hostName, port)

	user, err := inConfig.Get(name, "User")
	if err != nil {
		return "", nil, fmt.Errorf("cannot find User for '%s' in config: %v", name, err)
	}

	identityFile, err := inConfig.Get(name, "IdentityFile")
	if err != nil {
		return "", nil, fmt.Errorf("cannot find IdentityFile for '%s' in config: %v", name, err)
	}
	// Read the private key identified by identityFile.
	key, err := ioutil.ReadFile(identityFile)
	if err != nil {
		return "", nil, fmt.Errorf("unable to read private key from file '%s': %v", identityFile, err)
	}
	// Create the Signer for this private key.
	signer, err := ssh.ParsePrivateKey(key)
	if err != nil {
		return "", nil, fmt.Errorf("unable to parse private key from file '%s': %v", identityFile, err)
	}

	config := &ssh.ClientConfig{
		User:            user,
		Auth:            []ssh.AuthMethod{ssh.PublicKeys(signer)},
		HostKeyCallback: ssh.InsecureIgnoreHostKey(),
	}
	return host, config, nil
}

type VagrantProvider struct{}

func (provider *VagrantProvider) GetSSHConfig(name string) (string, *ssh.ClientConfig, error) {
	// We convert the Vagrant ssh config file (generated by "vagrant ssh-config"), which is an
	// OpenSSH config file, to an instance of ssh.ClientConfig.
	sshConfig, err := importConfig()
	if err != nil {
		return "", nil, err
	}
	return convertConfig(sshConfig, name)
}

func (provider *VagrantProvider) GetKubeconfigPath() (string, error) {
	vagrantPath, err := vagrantPath()
	if err != nil {
		return "", fmt.Errorf("cannot compute path to infra/vagrant")
	}
	kubeconfigPath := path.Join(vagrantPath, "playbook", "kube", "config")
	if _, err := os.Stat(kubeconfigPath); os.IsNotExist(err) {
		return "", fmt.Errorf("Kubeconfig file not found at expected location '%s'", kubeconfigPath)
	}
	return kubeconfigPath, nil
}

// configPath is unused for the vagrant provider
func NewVagrantProvider(configPath string) (ProviderInterface, error) {
	return &VagrantProvider{}, nil
}
